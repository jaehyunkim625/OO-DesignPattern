### Strategy Pattern (스트래티지패턴)

---
: 기본개념은 `행위(Behavior)`에 대한 로직을 사용자가 아닌, 다른Class(Implement)에 행위에 대한 로직을 `수행(Delegate)`하게하고, `사용자는 스트래티지(Interface)만을 사용`한다는것.
  도메인관점에서 의미있는 프로세스가 존재할 수 있고 (단지 기술적인이유가아님) 이런 프로세스의 중심 개념과 변경되는 부분을 따로 분리해야한다. (e.g. If-else로인한복잡도증가) 이 두 부분을 분리하면 중심프로세스와 그 외의 부가적인 코드를 더욱 명확히 식별할 수 있다. 프로세스에서 변화하는 부분은 별도의전략(Strategy)객체로 분리하여 모델로 표현한다.

* 전략을 디자인패턴으로 바라보는 전통적인 관점에서는 각기 다른 알고리즘을 상호 대체하는 능력에 중점을 두지만, 도메인패턴으로서 사용되는 관점에서는 프로세스나 정책적인 규칙과 같은, 상호 대체될 수 있는 여러 개념을 표현하는 능력에 중점을 둔다.

#### Pros) 호출클래스로직이 심플해짐, 컨텍스트 코드의 변경 없이 새로운 전략을 추가할 수 있다. 즉, Context에 대한 OCP 원칙을 만족하게 된다.
#### Cons) 구현부클래스(Implement)의 인스턴스생성을 해줘야함 -> 인스턴스생성은 factory클래스에 위임해야함, 그리고 사용되는 전략이 적다면, 복잡성만 늘어날 수 있다.

    * Context: 클라이언트가 직접 사용하는 클래스. Strategy 인터페이스를 위임하고(has) 하고 있음. 
    * Strategy(interface): 구체적인 알고리즘들의 공통 스펙을 정의하는 클래스 (e.g. doSomething)
    * ConcreteStrategy(implements): 구체적인 알고리즘들을 구현하는 클래스
---
